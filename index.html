<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>Ghi h√¨nh Pickleball</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root{
    --bg:#111; --panel:#000; --card:#222; --muted:#333; --muted2:#444; --ink:#fff; --accent:rgba(0,64,160,.65);
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:0; font-family:Arial,Helvetica,sans-serif;
    background:var(--bg); color:var(--ink);
    display:flex; flex-direction:row; gap:10px; height:100vh; overflow:hidden;
  }
  /* Left: Video area (max-width 320, 16:9) */
  .left-panel{
    flex:0 0 320px; max-width:320px; min-width:280px;
    display:flex; flex-direction:column; align-items:center; position:relative; background:var(--panel); padding:6px;
  }
  video, canvas{
    width:100%; aspect-ratio:16/9;
    background:#000; border:2px solid var(--muted2); border-radius:10px;
  }
  #camera{ display:none } /* ch·ªâ hi·ªÉn th·ªã canvas (ƒë·∫£m b·∫£o 1 khung h√¨nh duy nh·∫•t) */
  #scoreCanvas{ display:block }
  #liveIndicator{
    position:absolute; top:10px; left:12px; z-index:5;
    background:#e00; color:#fff; font-weight:bold; font-size:12px;
    padding:3px 8px; border-radius:999px; display:none; box-shadow:0 0 0 2px rgba(0,0,0,.35);
  }
  .controls-bottom{
    display:flex; flex-direction:column; gap:6px; width:100%; padding-top:8px;
  }
  .controls-bottom input, .controls-bottom select, .controls-bottom button{
    width:100%; font-size:12px; padding:6px 8px; margin:0;
    border-radius:8px; border:none; background:var(--muted); color:#fff; cursor:pointer;
  }
  .row{ display:flex; gap:6px; }
  .row > *{ flex:1 }
  .controls-bottom button:hover{ background:#555; }
  .right-panel{
    flex:1; display:flex; flex-direction:row; justify-content:space-evenly;
    align-items:flex-start; padding:6px; gap:10px; overflow:auto;
  }
  .card{
    background:var(--card); padding:8px; border-radius:12px; min-width:160px; max-width:240px;
    display:flex; flex-direction:column; align-items:center; gap:6px;
    border:1px solid #1a1a1a;
  }
  .card h3{ margin:4px 0 2px 0; font-size:14px; text-align:center }
  .stack{ display:flex; flex-direction:column; gap:6px; width:100% }
  .stack button, .stack input{ background:var(--muted); color:#fff; border:none; border-radius:8px; padding:6px 8px; cursor:pointer; font-size:12px }
  .stack button:disabled{ opacity:.45; cursor:not-allowed }
  .hint{ font-size:11px; opacity:.8; text-align:center }
  #progressContainer{
    position:absolute; inset:auto 10px 10px 10px;
    background:rgba(0,0,0,.7); padding:10px 12px; border-radius:10px; display:none; font-size:12px; text-align:center;
  }
  .downloads{ display:flex; gap:8px; margin-top:4px }
  .downloads a{
    background:#0a7; color:white; padding:6px 8px; border-radius:8px; text-decoration:none; font-size:12px; display:none;
  }
  /* Responsive landscape target iPhone 15 Pro width ~ 1179px height ~ 2556px in CSS px (rotated) ‚Äì b·ªë c·ª•c ƒë√£ g·ªçn s·∫µn */
  @media (max-width:880px){
    .right-panel{ gap:6px }
    .card{ min-width:150px }
  }
</style>
</head>
<body>

  <!-- LIVE indicator: DOM overlay (kh√¥ng v·∫Ω v√†o video) -->
  <div id="liveIndicator">‚óè LIVE</div>

  <!-- Video/Canvas Column -->
  <div class="left-panel">
    <video id="camera" autoplay playsinline muted></video>
    <canvas id="scoreCanvas"></canvas>

    <div class="controls-bottom">
      <input id="tournamentName" placeholder="T√™n gi·∫£i ƒë·∫•u" />
      <div class="row">
        <select id="resolution">
          <option value="720">720p</option>
          <option value="1080">1080p</option>
        </select>
        <button id="restartCamBtn" title="Kh·ªüi ƒë·ªông / ƒë·ªïi ƒë·ªô ph√¢n gi·∫£i">M·ªü camera</button>
      </div>
      <div class="row">
        <button id="recordBtn">Ghi h√¨nh</button>
        <button id="stopBtn" disabled>K·∫øt th√∫c</button>
        <button id="captureBtn">Ch·ª•p ·∫£nh</button>
      </div>
      <div id="progressContainer">ƒêang chuy·ªÉn MP4: 0%</div>
      <div class="downloads">
        <a id="dlWebM" download="pickleball_recording.webm">T·∫£i WebM</a>
        <a id="dlMP4" download="pickleball_recording.mp4">T·∫£i MP4</a>
      </div>
      <div class="hint">‚Ä¢ Kh√¥ng ph√°t √¢m thanh ra loa khi quay. Mic v·∫´n ƒë∆∞·ª£c ghi v√†o video.</div>
    </div>
  </div>

  <!-- Controls Column -->
  <div class="right-panel">
    <div class="card" id="teamABox">
      <h3 id="teamATitle">ƒê·ªôi A</h3>
      <div class="stack">
        <input id="teamAName" placeholder="T√™n ƒë·ªôi A" />
        <button id="chooseServerBtn">Ch·ªçn ƒë·ªôi giao l·∫ßn ƒë·∫ßu</button>
        <div class="row">
          <button id="serveAPlus">+ L∆∞·ª£t giao</button>
          <button id="serveAMinus">- L∆∞·ª£t giao</button>
        </div>
        <div class="row">
          <button id="scoreAPlus">+ ƒêi·ªÉm</button>
          <button id="scoreAMinus">- ƒêi·ªÉm</button>
        </div>
      </div>
    </div>

    <div class="card" id="teamBBox">
      <h3 id="teamBTitle">ƒê·ªôi B</h3>
      <div class="stack">
        <input id="teamBName" placeholder="T√™n ƒë·ªôi B" />
        <div class="row">
          <button id="serveBPlus">+ L∆∞·ª£t giao</button>
          <button id="serveBMinus">- L∆∞·ª£t giao</button>
        </div>
        <div class="row">
          <button id="scoreBPlus">+ ƒêi·ªÉm</button>
          <button id="scoreBMinus">- ƒêi·ªÉm</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ffmpeg.wasm -->
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.8/dist/ffmpeg.min.js"></script>
  <script>
  (()=>{
    // ---------- Elements ----------
    const vid = document.getElementById('camera');
    const canvas = document.getElementById('scoreCanvas');
    const ctx = canvas.getContext('2d');
    const liveEl = document.getElementById('liveIndicator');

    const tournamentNameEl = document.getElementById('tournamentName');
    const resSel = document.getElementById('resolution');
    const restartCamBtn = document.getElementById('restartCamBtn');
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const captureBtn = document.getElementById('captureBtn');
    const progressBox = document.getElementById('progressContainer');
    const dlWebM = document.getElementById('dlWebM');
    const dlMP4 = document.getElementById('dlMP4');

    const teamANameEl = document.getElementById('teamAName');
    const teamBNameEl = document.getElementById('teamBName');
    const teamATitle = document.getElementById('teamATitle');
    const teamBTitle = document.getElementById('teamBTitle');

    const chooseServerBtn = document.getElementById('chooseServerBtn');
    const serveAPlus = document.getElementById('serveAPlus');
    const serveAMinus = document.getElementById('serveAMinus');
    const serveBPlus = document.getElementById('serveBPlus');
    const serveBMinus = document.getElementById('serveBMinus');
    const scoreAPlus = document.getElementById('scoreAPlus');
    const scoreAMinus = document.getElementById('scoreAMinus');
    const scoreBPlus = document.getElementById('scoreBPlus');
    const scoreBMinus = document.getElementById('scoreBMinus');

    // ---------- State ----------
    let camStream = null;        // stream t·ª´ camera + mic
    let rec = null;              // MediaRecorder cho canvas + mic
    let chunks = [];
    let isRecording = false;

    let startEpoch = null;       // cho ƒë·ªìng h·ªì trong canvas (mm:ss)
    let rafId = null;

    const state = {
      A: { name: 'A', score: 0, serves: 0 },
      B: { name: 'B', score: 0, serves: 0 },
      current: null,             // 'A' | 'B' | null
      initialChosen: false
    };

    // ---------- UI helpers ----------
    function clampServe(v){ return Math.max(0, Math.min(2, v)); }

    function updateTitles(){
      teamATitle.textContent = state.A.name || 'ƒê·ªôi A';
      teamBTitle.textContent = state.B.name || 'ƒê·ªôi B';
    }

    function updateEnables(){
      // Sau khi CH·ªåN ƒë·ªôi giao l·∫ßn ƒë·∫ßu:
      chooseServerBtn.disabled = state.initialChosen;

      const aActive = state.A.serves > 0;
      const bActive = state.B.serves > 0;

      // Ch·ªâ ƒë·ªôi c√≤n l∆∞·ª£t giao m·ªõi c√≥ th·ªÉ +/‚àí ƒëi·ªÉm
      scoreAPlus.disabled = !aActive;
      scoreAMinus.disabled = !aActive;
      scoreBPlus.disabled = !bActive;
      scoreBMinus.disabled = !bActive;

      // +/‚àí l∆∞·ª£t giao: ch·ªâ ƒë·ªôi ƒëang c√≤n l∆∞·ª£t giao ƒë∆∞·ª£c thao t√°c
      serveAPlus.disabled = !aActive || state.A.serves>=2;
      serveAMinus.disabled = !aActive || state.A.serves<=0;
      serveBPlus.disabled = !bActive || state.B.serves>=2;
      serveBMinus.disabled = !bActive || state.B.serves<=0;

      // Khi ch∆∞a ch·ªçn server, v√¥ hi·ªáu t·∫•t c·∫£ n√∫t li√™n quan
      if(!state.initialChosen){
        serveAPlus.disabled = serveAMinus.disabled = true;
        serveBPlus.disabled = serveBMinus.disabled = true;
        scoreAPlus.disabled = scoreAMinus.disabled = true;
        scoreBPlus.disabled = scoreBMinus.disabled = true;
      }
    }

    // ---------- Serve & Score logic ----------
    function chooseInitialServer(team){ // team: 'A'|'B'
      if(state.initialChosen) return;
      state.initialChosen = true;
      state.current = team;
      state.A.serves = team==='A' ? 1 : 0; // l·∫ßn ƒë·∫ßu m·∫∑c ƒë·ªãnh 1 l∆∞·ª£t
      state.B.serves = team==='B' ? 1 : 0;
      updateEnables();
    }

    function rotateToOpponentTwoServes(){
      // ƒê·ªôi ƒëang giao ƒë√£ v·ªÅ 0 -> chuy·ªÉn sang ƒë·ªôi kia v·ªõi 2 l∆∞·ª£t
      const next = state.current === 'A' ? 'B' : 'A';
      state.current = next;
      state[next].serves = 2;
    }

    function addServe(team){
      if(!state.initialChosen) return;
      if(state[team].serves <= 1){ // t·ªëi ƒëa 2
        state[team].serves = clampServe(state[team].serves + 1);
      }
      updateEnables();
    }

    function subServe(team){
      if(!state.initialChosen) return;
      if(state[team].serves > 0){
        state[team].serves = clampServe(state[team].serves - 1);
        if(state[team].serves === 0){
          // Khi gi·∫£m v·ªÅ 0, k√≠ch ho·∫°t ƒë·ªôi kia v·ªõi 2 l∆∞·ª£t
          rotateToOpponentTwoServes();
        }
      }
      updateEnables();
    }

    function addScore(team){
      if(state[team].serves <= 0) return; // ch·ªâ ƒë∆∞·ª£c c·ªông khi c√≤n l∆∞·ª£t giao
      state[team].score = Math.max(0, state[team].score + 1);
      updateEnables();
    }
    function subScore(team){
      if(state[team].serves <= 0) return;
      state[team].score = Math.max(0, state[team].score - 1);
      updateEnables();
    }

    // ---------- Drawing (video -> canvas + overlay) ----------
    function draw(){
      rafId = requestAnimationFrame(draw);
      if(!vid.videoWidth) return;

      canvas.width = vid.videoWidth;
      canvas.height = vid.videoHeight;

      // Video frame
      ctx.drawImage(vid, 0, 0, canvas.width, canvas.height);

      // Top bar: tournament
      ctx.fillStyle = "rgba(0,0,100,0.65)";
      ctx.fillRect(0, 0, canvas.width, 48);
      ctx.fillStyle = "#fff";
      ctx.font = "20px Arial";
      ctx.textAlign = "center";
      ctx.fillText(tournamentNameEl.value || "", canvas.width/2, 30);

      // Bottom scoreboard bar
      const barH = 60;
      ctx.fillStyle = "rgba(0,64,160,0.65)";
      ctx.fillRect(0, canvas.height - barH, canvas.width, barH);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "24px Arial";

      const midX = canvas.width/2;
      // line 1: scores (A üèÜ B) centered a bit upper
      ctx.fillText(`${state.A.score}  üèÜ  ${state.B.score}`, midX, canvas.height - 36);

      // line 2: names aligned sides of center
      ctx.font = "18px Arial";
      ctx.textAlign = "right";
      ctx.fillText(state.A.name || "A", midX - 20, canvas.height - 14);
      ctx.textAlign = "left";
      ctx.fillText(state.B.name || "B", midX + 20, canvas.height - 14);

      // Serve indicators (ƒë·ªè) ‚Äì v·∫Ω trong canvas ƒë·ªÉ xu·∫•t hi·ªán trong video
      const dotR = 6;
      // A: b√™n tr√°i
      if(state.A.serves>0){
        for(let i=0;i<state.A.serves;i++){
          ctx.beginPath();
          ctx.arc(40 + i*16, canvas.height - 30, dotR, 0, Math.PI*2);
          ctx.fillStyle = "red";
          ctx.fill();
        }
      }
      // B: b√™n ph·∫£i
      if(state.B.serves>0){
        for(let i=0;i<state.B.serves;i++){
          ctx.beginPath();
          ctx.arc(canvas.width - 40 - i*16, canvas.height - 30, dotR, 0, Math.PI*2);
          ctx.fillStyle = "red";
          ctx.fill();
        }
      }

      // Timer (mm:ss) ‚Äì v·∫Ω trong canvas (ƒë∆∞·ª£c ghi v√†o video)
      if(startEpoch){
        const sec = Math.floor((Date.now() - startEpoch)/1000);
        const mm = String(Math.floor(sec/60)).padStart(2,'0');
        const ss = String(sec%60).padStart(2,'0');
        ctx.font = "18px Arial";
        ctx.textAlign = "right";
        ctx.fillStyle = "#fff";
        ctx.fillText(`${mm}:${ss}`, canvas.width - 10, 30);
      }
    }

    // ---------- Camera ----------
    async function startCamera(){
      // t·∫Øt stream c≈© (n·∫øu c√≥)
      if(camStream){
        camStream.getTracks().forEach(t=>t.stop());
        camStream = null;
      }

      const want1080 = resSel.value === '1080';
      const constraints = {
        audio: { echoCancellation:true, noiseSuppression:true, channelCount:1 },
        video: {
          facingMode: { ideal: "environment" },
          width:  want1080 ? { ideal: 1920 } : { ideal: 1280 },
          height: want1080 ? { ideal: 1080 } : { ideal: 720 },
          aspectRatio: 16/9,
          frameRate: { ideal: 30, max: 30 },
          // Kh√¥ng c√≥ API chu·∫©n ƒë·ªÉ "∆∞u ti√™n g√≥c r·ªông", nh∆∞ng facingMode 'environment' th∆∞·ªùng ch·ªçn camera sau; tr√¨nh duy·ªát c√≥ th·ªÉ ch·ªçn ·ªëng k√≠nh r·ªông n·∫øu c√≥.
        }
      };

      try{
        camStream = await navigator.mediaDevices.getUserMedia(constraints);
        vid.srcObject = camStream;
        vid.muted = true; // kh√¥ng ph√°t ra loa
        await vid.play();

        // B·∫Øt ƒë·∫ßu v·∫Ω
        if(!rafId) draw();
      }catch(err){
        alert("Kh√¥ng m·ªü ƒë∆∞·ª£c camera/micro: " + err);
      }
    }

    // ---------- Recording (canvas + mic) ----------
    function getMixedStream(){
      // Canvas (video)
      const cvsStream = canvas.captureStream(30);
      // Mic (t·ª´ camStream)
      const audioTrack = camStream ? camStream.getAudioTracks()[0] : null;
      if(audioTrack) cvsStream.addTrack(audioTrack);
      return cvsStream;
    }

    function resetDownloads(){
      [dlWebM, dlMP4].forEach(a=>{
        if(a.href){ URL.revokeObjectURL(a.href); }
        a.style.display = "none";
        a.removeAttribute('href');
      });
    }

    function startRecording(){
      if(isRecording) return;
      if(!camStream){ alert("Ch∆∞a m·ªü camera."); return; }

      resetDownloads();
      const stream = getMixedStream();
      rec = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9,opus' });
      chunks = [];
      rec.ondataavailable = e=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
      rec.onstop = onRecordStop;
      rec.start();

      startEpoch = Date.now();  // ch·∫°y timer trong canvas
      isRecording = true;
      liveEl.style.display = 'inline-block';
      recordBtn.disabled = true;
      stopBtn.disabled = false;
      restartCamBtn.disabled = true; // ƒëang quay th√¨ kh√¥ng ƒë·ªïi cam
    }

    function stopRecording(){
      if(!isRecording || !rec) return;
      rec.stop();
      isRecording = false;
      liveEl.style.display = 'none';
      recordBtn.disabled = false;
      stopBtn.disabled = true;
      restartCamBtn.disabled = false;
      startEpoch = null;

      // T·∫Øt camera sau khi k·∫øt th√∫c (theo y√™u c·∫ßu)
      if(camStream){
        camStream.getTracks().forEach(t=>t.stop());
        camStream = null;
      }
    }

    function onRecordStop(){
      const blob = new Blob(chunks, { type:'video/webm' });
      const url = URL.createObjectURL(blob);
      dlWebM.href = url;
      dlWebM.style.display = 'inline-block';

      // T·ª± chuy·ªÉn th√†nh MP4 (ffmpeg.wasm)
      convertToMP4(blob).catch(err=>{
        console.error(err);
        alert("Kh√¥ng chuy·ªÉn ƒë∆∞·ª£c MP4. B·∫°n c√≥ th·ªÉ d√πng file WebM.");
      });
    }

    // ---------- PNG Snap ----------
    function captureFrame(){
      if(!canvas.width){ alert("Ch∆∞a s·∫µn s√†ng khung h√¨nh."); return; }
      const link = document.createElement('a');
      link.download = 'pickleball_frame.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    // ---------- ffmpeg.wasm MP4 ----------
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({
      log:true,
      progress: p=>{
        if(typeof p?.ratio === 'number'){
          progressBox.style.display = 'block';
          progressBox.textContent = `ƒêang chuy·ªÉn MP4: ${Math.floor(p.ratio*100)}%`;
        }
      }
    });
    let ffmpegReady = false;

    async function ensureFFmpeg(){
      if(ffmpegReady) return;
      await ffmpeg.load();
      ffmpegReady = true;
    }

    async function convertToMP4(webmBlob){
      await ensureFFmpeg();
      // ghi input
      ffmpeg.FS('writeFile', 'in.webm', await fetchFile(webmBlob));
      // chuy·ªÉn ƒë·ªïi H.264 + AAC (n·∫øu kh√¥ng c√≥ AAC, ffmpeg.wasm map sang mp3 ‚Äì v·∫´n ph√°t tr√™n iOS m·ªõi; d√πng aac t·ªët h∆°n n·∫øu build h·ªó tr·ª£)
      await ffmpeg.run(
        '-i','in.webm',
        '-c:v','libx264','-preset','veryfast','-pix_fmt','yuv420p',
        '-movflags','faststart',
        '-c:a','aac','-b:a','128k',
        'out.mp4'
      );
      const data = ffmpeg.FS('readFile','out.mp4');
      const mp4Blob = new Blob([data.buffer], { type:'video/mp4' });
      const mp4Url = URL.createObjectURL(mp4Blob);
      dlMP4.href = mp4Url;
      dlMP4.style.display = 'inline-block';
      progressBox.style.display = 'none';
      // d·ªçn FS
      try{ ffmpeg.FS('unlink','in.webm'); ffmpeg.FS('unlink','out.mp4'); }catch{}
    }

    // ---------- Events wiring ----------
    restartCamBtn.addEventListener('click', startCamera);
    resSel.addEventListener('change', ()=>{
      // ƒë·ªïi ƒë·ªô ph√¢n gi·∫£i -> m·ªü l·∫°i camera
      startCamera();
    });
    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
    captureBtn.addEventListener('click', captureFrame);

    teamANameEl.addEventListener('input', e=>{ state.A.name = e.target.value || 'A'; updateTitles(); });
    teamBNameEl.addEventListener('input', e=>{ state.B.name = e.target.value || 'B'; updateTitles(); });

    chooseServerBtn.addEventListener('click', ()=>{
      // L·∫ßn ƒë·∫ßu ch·ªâ c√≥ 1 n√∫t ch·ªçn ‚Äì s·∫Ω ch·ªçn theo ƒë·ªôi A n·∫øu t√™n ƒëang ch·ªânh ·ªü A,
      // nh∆∞ng ƒë√∫ng y√™u c·∫ßu: "Ch·ªâ c·∫ßn 1 n√∫t ch·ªçn ƒë·ªôi giao banh l·∫ßn ƒë·∫ßu"
      // -> ta ch·ªçn ƒë·ªôi A n·∫øu ng∆∞·ªùi d√πng ƒëang click trong box A, m·∫∑c ƒë·ªãnh l√† A.
      chooseInitialServer('A');
    });
    // Tip nh·ªè: n·∫øu mu·ªën ch·ªçn ƒë·ªôi B l√†m l·∫ßn ƒë·∫ßu, nh·∫•n gi·ªØ Option: kh√¥ng c·∫ßn ‚Äì c√≥ th·ªÉ ƒë·ªïi nhanh b·∫±ng -/+ serve.

    // Serve A
    serveAPlus.addEventListener('click', ()=> addServe('A'));
    serveAMinus.addEventListener('click', ()=> subServe('A'));
    // Serve B
    serveBPlus.addEventListener('click', ()=> addServe('B'));
    serveBMinus.addEventListener('click', ()=> subServe('B'));
    // Score
    scoreAPlus.addEventListener('click', ()=> addScore('A'));
    scoreAMinus.addEventListener('click', ()=> subScore('A'));
    scoreBPlus.addEventListener('click', ()=> addScore('B'));
    scoreBMinus.addEventListener('click', ()=> subScore('B'));

    // ---------- Init ----------
    updateTitles();
    updateEnables();
    // M·∫∑c ƒë·ªãnh m·ªü camera l√∫c v√†o trang
    startCamera();

    // B·∫Øt ƒë·∫ßu v√≤ng v·∫Ω
    draw();
  })();
  </script>
</body>
</html>
